<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory Growing Map</title>
    <script src="https://cdn.jsdelivr.net/npm/@panzoom/panzoom@4.5.1/dist/panzoom.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Comic Sans MS', 'Yu Gothic', 'Hiragino Sans GB', sans-serif;
        }

        :root {
            --inverse-scale: 1; /* å®šä¹‰é»˜è®¤å€¼ï¼Œé¿å…CSSè§£æè­¦å‘Š */
        }

        body {
            background: linear-gradient(135deg, #e0f7fa, #bbdefb);
            min-height: 100vh;
            color: #333;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }

        header {
            grid-column: 1 / -1;
            text-align: center;
            margin-bottom: 20px;
        }

        h1 {
            font-size: 2.8rem;
            color: #5d4037;
            text-shadow: 3px 3px 0 #ffccbc;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.2rem;
            color: #795548;
            margin-bottom: 20px;
        }

        /* ç±»åˆ«è·³è½¬é€‰æ‹©å™¨ */
        .category-selector {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
        }

        .category-selector label {
            font-weight: bold;
            color: #5d4037;
        }

        .category-selector select {
            padding: 8px 15px;
            border: 3px solid #5d4037;
            border-radius: 8px;
            background: white;
            font-size: 1rem;
            cursor: pointer;
            box-shadow: 3px 3px 0 rgba(93, 64, 55, 0.2);
            transition: all 0.2s;
        }

        .category-selector select:hover {
            transform: translate(1px, 1px);
            box-shadow: 2px 2px 0 rgba(93, 64, 55, 0.2);
        }

        /* ä¾§è¾¹æ æ ·å¼ */
        .sidebar {
            background: #fffde7;
            border: 4px solid #5d4037;
            border-radius: 12px;
            box-shadow: 8px 8px 0 rgba(93, 64, 55, 0.2);
            padding: 20px;
            height: fit-content;
        }

        .memory-form {
            margin-bottom: 30px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #5d4037;
        }

        .form-control {
            width: 100%;
            padding: 10px;
            border: 2px solid #a1887f;
            border-radius: 8px;
            background: white;
            font-size: 1rem;
        }

        textarea.form-control {
            min-height: 100px;
            resize: vertical;
        }

        .hidden-input {
            display: none; /* è¿™ä¼šéšè—ä¸‘ä¸‘çš„é»˜è®¤æŒ‰é’® */
        }

        .file-name-display {
            display: block;
            margin-top: 8px;
            text-align: center;
            font-size: 0.9rem;
            color: #5d4037;
            font-style: italic;
        }

        .memory-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .memory-item {
            background: white;
            border: 2px solid #a1887f;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .memory-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 0 #a1887f;
        }

        .memory-item.active {
            border-color: #ff5722;
            background: #fff3e0;
        }

        .memory-title {
            font-weight: bold;
            color: #5d4037;
            margin-bottom: 5px;
        }

        .memory-date {
            font-size: 0.8rem;
            color: #8d6e63;
        }

        /* åœ°å›¾å®¹å™¨æ ·å¼ - æ— é™ç”»å¸ƒ */
        .map-container {
            background: #fffde7;
            border: 4px solid #5d4037;
            border-radius: 12px;
            box-shadow: 8px 8px 0 rgba(93, 64, 55, 0.2);
            padding: 20px;
            position: relative;
            overflow: hidden; /* éšè—è¶…å‡ºéƒ¨åˆ† */
            height: 600px;
        }

        .base-map {
            width: 3000px;  /* è¶…å¤§ç”»å¸ƒ */
            height: 3000px; /* è¶…å¤§ç”»å¸ƒ */
            background: #c8e6c9;
            border-radius: 8px;
            position: relative;
            cursor: grab;
        }

        /* 1. æ–°å¢: SVG ç”»å¸ƒå±‚æ ·å¼ */
        .svg-line-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5; /* ç¡®ä¿å®ƒåœ¨åœ°å›¾èƒŒæ™¯ä¹‹ä¸Š, åœ¨å»ºç­‘ä¹‹ä¸‹ */
            pointer-events: none; /* å…³é”®: è®©é¼ æ ‡å¯ä»¥ç‚¹å‡»ç©¿é€å®ƒ */
        }

        /* 2. æ–°å¢: è®°å¿†èŠ‚ç‚¹ (åœ¨å»ºç­‘è„šä¸‹) */
        .memory-node {
            width: 20px;
            height: 20px;
            border: 3px solid #5d4037; /* æ¼«ç”»é£æ ¼è¾¹æ¡† */
            border-radius: 50%;
            position: absolute;
            bottom: -10px; /* æ”¾åœ¨"è„šä¸‹" */
            left: 50%;
            box-shadow: 2px 2px 0 rgba(93, 64, 55, 0.2);
            z-index: 15;
            cursor: pointer;
            transition: all 0.3s ease;

            /* 3. æ–°å¢: åŠ¨ç”»å…‰æ•ˆ (è„‰å†²) */
            animation: pulse-glow 2.5s infinite ease-in-out;
        }

        /* 4. æ–°å¢: èŠ‚ç‚¹å…‰æ•ˆåŠ¨ç”» */
        @keyframes pulse-glow {
            0% {
                transform: translateX(-50%) scale(1);
                opacity: 0.7;
            }
            50% {
                transform: translateX(-50%) scale(1.25);
                opacity: 1;
                /* ä½¿ç”¨ currentColor æ¥è·å–èŠ‚ç‚¹çš„èƒŒæ™¯è‰² */
                box-shadow: 2px 2px 0 rgba(93, 64, 55, 0.2), 0 0 15px currentColor;
            }
            100% {
                transform: translateX(-50%) scale(1);
                opacity: 0.7;
            }
        }

        /* 5. æ–°å¢: è®°å¿†è¿æ¥çº¿ */
        .connection-line {
            fill: none;
            stroke-width: 4px; /* ç²—çº¿æ¡, åŒ¹é…æ¼«ç”»é£æ ¼ */
            stroke-linecap: round;
            opacity: 0.5;
            transition: all 0.3s ease;

            /* 6. æ–°å¢: å…³é”®! åº”ç”¨æ‰‹ç»˜æ»¤é•œ */
            filter: url(#wobbly-line);
        }

        /* 7. æ–°å¢: æ‚¬åœæ•ˆæœ */
        .memory-element:hover .memory-node {
            transform: translateX(-50%) scale(1.4);
            /* å¼ºå¤§çš„å…‰æ™•æ•ˆæœ */
            filter: drop-shadow(0 0 12px currentColor) drop-shadow(0 0 6px currentColor);
            animation: none; /* æ‚¬åœæ—¶åœæ­¢è„‰å†², ä¿æŒé«˜äº® */
            opacity: 1;
        }

        .connection-line.highlight {
            stroke-width: 6px;
            opacity: 0.9;
        }

        /* 8. æ–°å¢: ç”¨äºä»åˆ—è¡¨é¡¹æ‚¬åœæ—¶é«˜äº®åœ°å›¾å…ƒç´  */
        .memory-element.hover-highlight {
            transform: scale(1.1); /* è½»è½»æ”¾å¤§ */
            z-index: 99;
        }

        /* è®°å¿†å…ƒç´ æ ·å¼ */
        .memory-element {
            position: absolute;
            transition: all 0.8s ease-out;
            transform-origin: center;
            cursor: pointer;
            z-index: 10;
            /* å…³é”®ï¼šä½¿ç”¨ CSS å˜é‡æ¥æ§åˆ¶åå‘ç¼©æ”¾ */
            transform: scale(var(--inverse-scale, 1));
        }

        .memory-element.growing {
            animation: growElement 1.5s ease-out forwards;
        }

        @keyframes growElement {
            0% {
                transform: scale(0) rotate(-10deg);
                opacity: 0;
            }
            70% {
                transform: scale(1.1) rotate(5deg);
            }
            100% {
                transform: scale(1) rotate(0);
                opacity: 1;
            }
        }

        .memory-bubble {
            background: white;
            border: 3px solid #5d4037;
            border-radius: 20px;
            padding: 15px;
            max-width: 200px;
            box-shadow: 5px 5px 0 rgba(93, 64, 55, 0.2);
            position: relative;
        }

        .memory-bubble:after {
            content: '';
            position: absolute;
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
            border-width: 15px 15px 0;
            border-style: solid;
            border-color: white transparent;
        }

        .memory-bubble:before {
            content: '';
            position: absolute;
            bottom: -19px;
            left: 50%;
            transform: translateX(-50%);
            border-width: 17px 17px 0;
            border-style: solid;
            border-color: #5d4037 transparent;
        }

        .memory-icon {
            font-size: 2rem;
            text-align: center;
            margin-bottom: 10px;
        }

        .memory-content {
            text-align: center;
        }

        .memory-element-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #5d4037;
        }

        .memory-element-date {
            font-size: 0.8rem;
            color: #8d6e63;
        }

        /* è®°å¿†è¯¦æƒ…é¢æ¿ */
        .memory-detail {
            position: absolute;
            top: 30px;
            right: 30px;
            width: 350px;
            background: white;
            border: 3px solid #5d4037;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 8px 8px 0 rgba(93, 64, 55, 0.2);
            display: none;
            z-index: 100;
        }

        .memory-detail.active {
            display: block;
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .detail-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 2px solid #ffccbc;
            padding-bottom: 10px;
        }

        .detail-title {
            font-size: 1.5rem;
            color: #5d4037;
            flex-grow: 1;
        }

        .close-detail {
            background: #ffab91;
            color: #5d4037;
            border: 2px solid #5d4037;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: bold;
        }

        .detail-content {
            margin-bottom: 15px;
        }

        .detail-image {
            width: 100%;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 2px solid #a1887f;
        }

        .detail-text {
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .detail-audio {
            width: 100%;
            margin-bottom: 15px;
        }

        /* æŒ‰é’®æ ·å¼ */
        .comic-button {
            background: #ffab91;
            color: #5d4037;
            border: 3px solid #5d4037;
            padding: 10px 20px;
            font-size: 1rem;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 4px 4px 0 #5d4037;
            transition: all 0.2s;
            display: inline-block;
            text-align: center;
        }

        .comic-button:hover {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 #5d4037;
        }

        .comic-button.full-width {
            width: 100%;
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 1100px) {
            .container {
                grid-template-columns: 1fr;
            }

            .sidebar {
                order: 2;
            }

            .map-container {
                order: 1;
                height: 500px;
            }
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }

            .memory-detail {
                width: calc(100% - 60px);
            }
        }
    </style>
</head>
<body>
<div class="container">
    <header>
        <h1>Memory Growing Space</h1>
        <p class="subtitle">Seed a memory, grow a world</p>
        <div class="category-selector">
            <label for="categoryJump">å¿«é€Ÿè·³è½¬ï¼š</label>
            <select id="categoryJump">
                <option value="">-- é€‰æ‹©ç±»åˆ« --</option>
                <option value="food">ğŸœ ç¾é£Ÿè®°å¿†</option>
                <option value="travel">âœˆï¸ æ—…è¡Œè®°å¿†</option>
                <option value="family">ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ å®¶åº­è®°å¿†</option>
                <option value="friend">ğŸ‘« æœ‹å‹è®°å¿†</option>
                <option value="work">ğŸ’¼ å·¥ä½œè®°å¿†</option>
                <option value="study">ğŸ“š å­¦ä¹ è®°å¿†</option>
            </select>
        </div>
    </header>

    <div class="sidebar">
        <div class="memory-form">
            <h2>æ·»åŠ æ–°è®°å¿†</h2>
            <div class="form-group">
                <label for="memoryTitle">è®°å¿†æ ‡é¢˜</label>
                <input type="text" id="memoryTitle" class="form-control" placeholder="ä¾‹å¦‚ï¼šé£Ÿåœ¨å¹¿å·">
            </div>
            <div class="form-group">
                <label for="memoryType">è®°å¿†ç±»å‹</label>
                <select id="memoryType" class="form-control">
                    <option value="food">ç¾é£Ÿè®°å¿†</option>
                    <option value="travel">æ—…è¡Œè®°å¿†</option>
                    <option value="family">å®¶åº­è®°å¿†</option>
                    <option value="friend">æœ‹å‹è®°å¿†</option>
                    <option value="work">å·¥ä½œè®°å¿†</option>
                    <option value="study">å­¦ä¹ è®°å¿†</option>
                </select>
            </div>
            <div class="form-group">
                <label for="memoryDate">è®°å¿†æ—¥æœŸ</label>
                <input type="date" id="memoryDate" class="form-control">
            </div>
            <div class="form-group">
                <label for="memoryContent">è®°å¿†å†…å®¹</label>
                <textarea id="memoryContent" class="form-control" placeholder="æè¿°è¿™æ®µè®°å¿†..."></textarea>
            </div>
            <div class="form-group">
                <label for="memoryImage" class="comic-button full-width">ğŸ¨ é€‰æ‹©å›¾ç‰‡</label>
                <span id="image-file-name" class="file-name-display">æœªé€‰æ‹©æ–‡ä»¶</span>
                <input type="file" id="memoryImage" class="hidden-input" accept="image/*">
            </div>
            <div class="form-group">
                <label for="memoryAudio" class="comic-button full-width">ğŸµ é€‰æ‹©éŸ³é¢‘</label>
                <span id="audio-file-name" class="file-name-display">æœªé€‰æ‹©æ–‡ä»¶</span>
                <input type="file" id="memoryAudio" class="hidden-input" accept="audio/*">
            </div>
            <button id="addMemory" class="comic-button full-width">æ·»åŠ åˆ°è®°å¿†åœ°å›¾</button>
        </div>

        <div class="memory-list">
            <h2>è®°å¿†åˆ—è¡¨</h2>
            <div id="memoriesContainer">
                <!-- è®°å¿†é¡¹å°†é€šè¿‡JSåŠ¨æ€æ·»åŠ  -->
            </div>
        </div>
    </div>

    <div class="map-container">
        <!-- è®°å¿†å…ƒç´ å°†é€šè¿‡JSåŠ¨æ€æ·»åŠ  -->
        <div class="base-map" id="baseMap">

            <svg id="svgLines" class="svg-line-layer"></svg>

            <svg width="0" height="0" style="position:absolute; z-index: -1;">
                <defs>
                    <filter id="wobbly-line">
                        <feTurbulence type="fractalNoise" baseFrequency="0.02" numOctaves="3" result="noise" />
                        <feDisplacementMap in="SourceGraphic" in2="noise" scale="4" />
                    </filter>
                </defs>
            </svg>
        </div>
    </div>

    <div class="memory-detail" id="memoryDetail">
        <div class="detail-header">
            <h3 class="detail-title" id="detailTitle">è®°å¿†æ ‡é¢˜</h3>
            <div class="close-detail" id="closeDetail">Ã—</div>
        </div>
        <div class="detail-content">
            <img src="" alt="è®°å¿†å›¾ç‰‡" class="detail-image" id="detailImage">
            <p class="detail-text" id="detailText">è®°å¿†å†…å®¹...</p>
            <audio controls class="detail-audio" id="detailAudio">
                æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘å…ƒç´ ã€‚
            </audio>
        </div>
        <div class="detail-date" id="detailDate">æ—¥æœŸï¼š</div>
    </div>
</div>
</div>

<script>
    // è®°å¿†æ•°æ®å­˜å‚¨
    let memories = JSON.parse(localStorage.getItem('memories')) || [];
    let nextMemoryId = memories.length > 0 ? Math.max(...memories.map(m => m.id)) + 1 : 1;

    // Panzoom å®ä¾‹ï¼ˆå…¨å±€ï¼‰
    let panzoomInstance = null;

    // ç±»åˆ«ä¸­å¿ƒç‚¹é…ç½®ï¼ˆåƒé’Ÿè¡¨ä¸€æ ·åˆ†å¸ƒåœ¨6ä¸ªæ–¹å‘ï¼‰
    const categoryCenters = {
        food: { angle: 0, x: 2200, y: 1500 },      // 3ç‚¹é’Ÿæ–¹å‘
        travel: { angle: 60, x: 2200, y: 800 },    // 1ç‚¹é’Ÿæ–¹å‘
        study: { angle: 120, x: 1500, y: 500 },    // 11ç‚¹é’Ÿæ–¹å‘
        family: { angle: 180, x: 800, y: 800 },    // 9ç‚¹é’Ÿæ–¹å‘
        friend: { angle: 240, x: 800, y: 1500 },   // 7ç‚¹é’Ÿæ–¹å‘
        work: { angle: 300, x: 1500, y: 2200 }     // 5ç‚¹é’Ÿæ–¹å‘
    };

    // DOMå…ƒç´ 
    const baseMap = document.getElementById('baseMap');
    const memoriesContainer = document.getElementById('memoriesContainer');
    const memoryDetail = document.getElementById('memoryDetail');
    const detailTitle = document.getElementById('detailTitle');
    const detailText = document.getElementById('detailText');
    const detailImage = document.getElementById('detailImage');
    const detailAudio = document.getElementById('detailAudio');
    const detailDate = document.getElementById('detailDate');
    const closeDetail = document.getElementById('closeDetail');
    const addMemoryBtn = document.getElementById('addMemory');

    // è®°å¿†ç±»å‹é…ç½®
    const memoryTypes = {
        food: { icon: 'ğŸœ', color: '#ffab91', name: 'ç¾é£Ÿè®°å¿†' },
        travel: { icon: 'âœˆï¸', color: '#81d4fa', name: 'æ—…è¡Œè®°å¿†' },
        family: { icon: 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§', color: '#ce93d8', name: 'å®¶åº­è®°å¿†' },
        friend: { icon: 'ğŸ‘«', color: '#a5d6a7', name: 'æœ‹å‹è®°å¿†' },
        work: { icon: 'ğŸ’¼', color: '#ffcc80', name: 'å·¥ä½œè®°å¿†' },
        study: { icon: 'ğŸ“š', color: '#90caf9', name: 'å­¦ä¹ è®°å¿†' }
    };

    // --- 3. æ–°å¢: è·å– SVG å›¾å±‚ (ç”¨äºç‚¹å‡»åˆ¤æ–­) ---
    const svgLayer = document.getElementById('svgLines');

    // åˆå§‹åŒ–
    document.addEventListener('DOMContentLoaded', function() {
        // åŠ è½½å·²æœ‰è®°å¿†
        loadMemories();

        // æ·»åŠ è®°å¿†äº‹ä»¶
        addMemoryBtn.addEventListener('click', addNewMemory);

        // å…³é—­è¯¦æƒ…é¢æ¿
        closeDetail.addEventListener('click', function() {
            memoryDetail.classList.remove('active');
        });

        // --- ä¿®å¤: Panzoom é…ç½® - åœ°å›¾æ°¸è¿œå¡«æ»¡è§†å£ ---
        const panzoomOptions = {
            maxScale: 5,          // æœ€å¤§ç¼©æ”¾ 5å€
            minScale: 0.3,        // æœ€å°ç¼©æ”¾ 0.3å€
            startScale: 1,        // åˆå§‹ç¼©æ”¾æ¯”ä¾‹
            contain: 'outside',   // å…³é”®ï¼šåœ°å›¾æ°¸è¿œä¸ä¼šéœ²å‡ºå¤–éƒ¨èƒŒæ™¯
            cursor: 'grab',
            excludeClass: 'memory-element'
        };

        // åœ¨ baseMap ä¸Šåˆå§‹åŒ–å¹¶ä¿å­˜å®ä¾‹
        panzoomInstance = Panzoom(baseMap, panzoomOptions);

        // å¯ç”¨é¼ æ ‡æ»šè½®ç¼©æ”¾
        baseMap.parentElement.addEventListener('wheel', panzoomInstance.zoomWithWheel);

        // ç›‘å¬ç¼©æ”¾äº‹ä»¶ï¼ŒåŠ¨æ€è°ƒæ•´å…ƒç´ å°ºå¯¸
        baseMap.addEventListener('panzoom:zoom', function(e) {
            const scale = e.detail.scale;
            const inverseScale = 1 / scale;

            // æ›´æ–°æ‰€æœ‰è®°å¿†å…ƒç´ çš„åå‘ç¼©æ”¾
            document.querySelectorAll('.memory-element').forEach(el => {
                el.style.setProperty('--inverse-scale', inverseScale);
            });
        });

        // ç±»åˆ«è·³è½¬åŠŸèƒ½
        const categoryJump = document.getElementById('categoryJump');
        categoryJump.addEventListener('change', function() {
            const category = this.value;
            if (category && categoryCenters[category]) {
                jumpToCategory(category);
                this.value = ''; // é‡ç½®é€‰æ‹©å™¨
            }
        });

        // ç‚¹å‡»ç©ºç™½å¤„å…³é—­è¯¦æƒ…é¢æ¿
        baseMap.addEventListener('panzoom:click', function(e) {
            // åªæœ‰å½“ç‚¹å‡»ç›®æ ‡æ˜¯åœ°å›¾æœ¬èº«(æˆ–çº¿æ¡å±‚)æ—¶, æ‰å…³é—­è¯¦æƒ…
            if (e.target === baseMap || e.target === svgLayer) {
                memoryDetail.classList.remove('active');
            }
        });

        // æ‹–åŠ¨æ—¶åˆ‡æ¢å…‰æ ‡ä¸º grabbing
        baseMap.addEventListener('panzoom:panstart', () => {
            baseMap.style.cursor = 'grabbing';
        });
        baseMap.addEventListener('panzoom:panend', () => {
            baseMap.style.cursor = 'grab';
        });

        // åˆå§‹åŒ–å®Œæˆåï¼Œå¦‚æœæœ‰è®°å¿†åˆ™è‡ªåŠ¨ç¼©æ”¾åˆ°åˆé€‚è§†å›¾
        if (memories.length > 0) {
            setTimeout(() => {
                fitToMemories();
            }, 100);
        }

        // æ‹–åŠ¨æ—¶åˆ‡æ¢å…‰æ ‡
        baseMap.addEventListener('panzoom:panstart', () => {
            baseMap.style.cursor = 'grabbing';
        });
        baseMap.addEventListener('panzoom:panend', () => {
            baseMap.style.cursor = 'grab';
        });

        // ç›‘å¬æ–‡ä»¶ä¸Šä¼ æŒ‰é’®ï¼Œæ˜¾ç¤ºæ–‡ä»¶å
        const memoryImageInput = document.getElementById('memoryImage');
        const memoryAudioInput = document.getElementById('memoryAudio');
        const imageFileName = document.getElementById('image-file-name');
        const audioFileName = document.getElementById('audio-file-name');

        memoryImageInput.addEventListener('change', function() {
            if (this.files.length > 0) {
                imageFileName.textContent = this.files[0].name;
            } else {
                imageFileName.textContent = 'æœªé€‰æ‹©æ–‡ä»¶';
            }
        });

        memoryAudioInput.addEventListener('change', function() {
            if (this.files.length > 0) {
                audioFileName.textContent = this.files[0].name;
            } else {
                audioFileName.textContent = 'æœªé€‰æ‹©æ–‡ä»¶';
            }
        });
    });

    // åŠ è½½è®°å¿†
    function loadMemories() {
        // æ¸…ç©ºå®¹å™¨
        memoriesContainer.innerHTML = '';

        // æŒ‰æ—¥æœŸæ’åºï¼ˆæœ€æ–°çš„åœ¨å‰ï¼‰
        const sortedMemories = [...memories].sort((a, b) => new Date(b.date) - new Date(a.date));

        // æ·»åŠ è®°å¿†åˆ°åˆ—è¡¨
        sortedMemories.forEach(memory => {
            addMemoryToList(memory);
            const memoryElement = addMemoryToMap(memory);
            memory.element = memoryElement;
        });

        // --- æ–°å¢: åœ¨æ‰€æœ‰å…ƒç´ éƒ½åŠ è½½å, ç»˜åˆ¶æ‰€æœ‰ç±»å‹çš„çº¿æ¡ ---
        Object.keys(memoryTypes).forEach(type => {
            updateMemoryLines(type);
        });
    }

    // æ·»åŠ è®°å¿†åˆ°åˆ—è¡¨
    function addMemoryToList(memory) {
        const memoryItem = document.createElement('div');
        memoryItem.className = 'memory-item';
        memoryItem.dataset.id = memory.id;

        memoryItem.innerHTML = `
            <div class="memory-title">${memory.title}</div>
            <div class="memory-date">${formatDate(memory.date)} â€¢ ${memoryTypes[memory.type].name}</div>
        `;

        memoryItem.addEventListener('click', function() {
            // é«˜äº®æ˜¾ç¤º
            document.querySelectorAll('.memory-item').forEach(item => {
                item.classList.remove('active');
            });
            this.classList.add('active');

            // æ˜¾ç¤ºè¯¦æƒ…
            showMemoryDetail(memory);
        });

        // æ‚¬åœåˆ—è¡¨é¡¹æ—¶é«˜äº®åœ°å›¾å…ƒç´ å’Œçº¿æ¡
        memoryItem.addEventListener('mouseover', () => {
            if (memory.element) {
                memory.element.classList.add('hover-highlight');
                // è§¦å‘çº¿æ¡é«˜äº®
                document.querySelectorAll(`.connection-line[data-type="${memory.type}"]`).forEach(line => line.classList.add('highlight'));
            }
        });
        memoryItem.addEventListener('mouseout', () => {
            if (memory.element) {
                memory.element.classList.remove('hover-highlight');
                // å–æ¶ˆçº¿æ¡é«˜äº®
                document.querySelectorAll(`.connection-line.highlight[data-type="${memory.type}"]`).forEach(line => line.classList.remove('highlight'));
            }
        });

        memoriesContainer.appendChild(memoryItem);
    }

    // æ·»åŠ è®°å¿†åˆ°åœ°å›¾
    function addMemoryToMap(memory, animate = false) {
        // 1. å®šä¹‰ä¸€ä¸ªå»ºç­‘å›¾ç‰‡æ˜ å°„
        const buildingImages = {
            food: 'images/food_memory.png',
            travel: 'images/travel_memory.png',
            study: 'images/study_memory.png',
            family: 'images/family_memory.png',
            friend: 'images/friend_memory.png',
            work: 'images/work_memory.png'
        };

        // 2. è·å–å¯¹åº”çš„å›¾ç‰‡è·¯å¾„
        const buildingImageSrc = buildingImages[memory.type];

        const memoryElement = document.createElement('div');
        memoryElement.className = 'memory-element';
        memoryElement.dataset.id = memory.id;

        // 3. ä½¿ç”¨èšç±»å¸ƒå±€ï¼šåœ¨ç±»åˆ«ä¸­å¿ƒç‚¹é™„è¿‘éšæœºåˆ†å¸ƒ
        const center = categoryCenters[memory.type];
        const spreadRadius = 300; // èšç±»åŠå¾„
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * spreadRadius;

        const x = center.x + Math.cos(angle) * distance;
        const y = center.y + Math.sin(angle) * distance;

        memoryElement.style.left = `${x}px`;
        memoryElement.style.top = `${y}px`;

        // 4. ä¸å†ç”¨ bubble, è€Œæ˜¯ç”¨ <img>
        memoryElement.innerHTML = `
            <img src="${buildingImageSrc}" alt="${memory.title}" style="width: 100px; height: auto;">
            <div class="memory-element-title" style="text-align: center; margin-top: 5px;">${memory.title}</div>
        `;

        // åˆ›å»ºè®°å¿†èŠ‚ç‚¹
        const node = document.createElement('div');
        node.className = 'memory-node';
        node.style.backgroundColor = memoryTypes[memory.type].color;
        node.style.borderColor = memoryTypes[memory.type].color;
        node.style.color = memoryTypes[memory.type].color;

        memoryElement.appendChild(node);
        memoryElement.memoryNode = node;

        // æ·»åŠ æ‚¬åœäº‹ä»¶æ¥é«˜äº®çº¿æ¡
        memoryElement.addEventListener('mouseover', () => {
            document.querySelectorAll(`.connection-line[data-type="${memory.type}"]`).forEach(line => line.classList.add('highlight'));
        });
        memoryElement.addEventListener('mouseout', () => {
            document.querySelectorAll(`.connection-line.highlight[data-type="${memory.type}"]`).forEach(line => line.classList.remove('highlight'));
        });

        // æ·»åŠ ç‚¹å‡»äº‹ä»¶
        memoryElement.addEventListener('click', function(e) {
            e.stopPropagation();
            showMemoryDetail(memory);

            // åœ¨åˆ—è¡¨ä¸­ä¹Ÿé«˜äº®æ˜¾ç¤º
            document.querySelectorAll('.memory-item').forEach(item => {
                item.classList.remove('active');
                if (Number(item.dataset.id) === memory.id) {
                    item.classList.add('active');
                }
            });
        });

        baseMap.appendChild(memoryElement);

        // åˆå§‹åŒ–æ—¶è®¾ç½®åå‘ç¼©æ”¾ï¼ˆåŸºäºå½“å‰ç¼©æ”¾çº§åˆ«ï¼‰
        if (panzoomInstance) {
            const currentScale = panzoomInstance.getScale();
            memoryElement.style.setProperty('--inverse-scale', 1 / currentScale);
        }

        // æ·»åŠ ç”Ÿé•¿åŠ¨ç”»
        if (animate) {
            memoryElement.classList.add('growing');
            setTimeout(() => {
                memoryElement.classList.remove('growing');
            }, 1500);
        }

        return memoryElement;
    }

    // æ˜¾ç¤ºè®°å¿†è¯¦æƒ…
    function showMemoryDetail(memory) {
        detailTitle.textContent = memory.title;
        detailText.textContent = memory.content;
        detailDate.textContent = `æ—¥æœŸï¼š${formatDate(memory.date)}`;

        // è®¾ç½®å›¾ç‰‡
        if (memory.image) {
            detailImage.src = memory.image;
            detailImage.style.display = 'block';
        } else {
            detailImage.style.display = 'none';
        }

        // è®¾ç½®éŸ³é¢‘
        if (memory.audio) {
            detailAudio.src = memory.audio;
            detailAudio.style.display = 'block';
        } else {
            detailAudio.style.display = 'none';
        }

        memoryDetail.classList.add('active');
    }

    // æ·»åŠ æ–°è®°å¿†
    function addNewMemory() {
        const title = document.getElementById('memoryTitle').value;
        const type = document.getElementById('memoryType').value;
        const date = document.getElementById('memoryDate').value;
        const content = document.getElementById('memoryContent').value;
        const imageFile = document.getElementById('memoryImage').files[0];
        const audioFile = document.getElementById('memoryAudio').files[0];

        if (!title || !date || !content) {
            alert('è¯·å¡«å†™å®Œæ•´çš„è®°å¿†ä¿¡æ¯ï¼');
            return;
        }

        // åˆ›å»ºæ–°è®°å¿†å¯¹è±¡
        const newMemory = {
            id: nextMemoryId++,
            title,
            type,
            date,
            content,
            image: null,
            audio: null
        };

        // å¤„ç†å›¾ç‰‡æ–‡ä»¶
        if (imageFile) {
            const reader = new FileReader();
            reader.onload = function(e) {
                newMemory.image = e.target.result;
                finishAddingMemory(newMemory);
            };
            reader.readAsDataURL(imageFile);
        } else {
            finishAddingMemory(newMemory);
        }

        // å¤„ç†éŸ³é¢‘æ–‡ä»¶
        if (audioFile) {
            const reader = new FileReader();
            reader.onload = function(e) {
                newMemory.audio = e.target.result;
                // å¦‚æœå·²ç»æœ‰å›¾ç‰‡ï¼Œä¸éœ€è¦å†æ¬¡è°ƒç”¨finishAddingMemory
                if (!imageFile) {
                    finishAddingMemory(newMemory);
                }
            };
            reader.readAsDataURL(audioFile);
        } else if (!imageFile) {
            // å¦‚æœæ²¡æœ‰å›¾ç‰‡å’ŒéŸ³é¢‘ï¼Œç›´æ¥å®Œæˆ
            finishAddingMemory(newMemory);
        }
    }

    // å®Œæˆæ·»åŠ è®°å¿†
    function finishAddingMemory(memory) {
        // æ·»åŠ åˆ°è®°å¿†æ•°ç»„
        memories.push(memory);

        // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
        localStorage.setItem('memories', JSON.stringify(memories));

        // æ›´æ–°UI
        addMemoryToList(memory);
        const memoryElement = addMemoryToMap(memory, true);
        memory.element = memoryElement;

        // æ›´æ–°è¯¥ç±»å‹çš„çº¿æ¡
        updateMemoryLines(memory.type);

        // è‡ªåŠ¨é€‚åº”è§†å›¾åˆ°æ‰€æœ‰èŠ‚ç‚¹
        setTimeout(() => {
            fitToMemories();
        }, 1600); // ç­‰å¾…ç”Ÿé•¿åŠ¨ç”»å®Œæˆ

        // é‡ç½®è¡¨å•
        document.getElementById('memoryTitle').value = '';
        document.getElementById('memoryContent').value = '';
        document.getElementById('memoryImage').value = '';
        document.getElementById('memoryAudio').value = '';
        document.getElementById('image-file-name').textContent = 'æœªé€‰æ‹©æ–‡ä»¶';
        document.getElementById('audio-file-name').textContent = 'æœªé€‰æ‹©æ–‡ä»¶';

        // æ˜¾ç¤ºæç¤º
        alert('è®°å¿†å·²æˆåŠŸæ·»åŠ åˆ°åœ°å›¾ï¼');
    }

    // æ ¼å¼åŒ–æ—¥æœŸ
    function formatDate(dateString) {
        const date = new Date(dateString);
        return `${date.getFullYear()}å¹´${date.getMonth() + 1}æœˆ${date.getDate()}æ—¥`;
    }

    /**
     * æ›´æ–°å¹¶é‡ç»˜ä¸€ä¸ªç‰¹å®šç±»å‹çš„æ‰€æœ‰è®°å¿†è¿æ¥çº¿
     * @param {string} type - è®°å¿†ç±»å‹ (e.g., 'food', 'study')
     */
    function updateMemoryLines(type) {
        const svgLayer = document.getElementById('svgLines');

        // 1. æ¸…é™¤æ­¤ç±»å‹çš„æ‰€æœ‰æ—§çº¿æ¡
        svgLayer.querySelectorAll(`.connection-line[data-type="${type}"]`).forEach(line => line.remove());

        // 2. æ‰¾åˆ°æ­¤ç±»å‹çš„æ‰€æœ‰è®°å¿†, å¹¶æŒ‰æ—¥æœŸæ’åº
        const elements = memories
            .filter(m => m.type === type && m.element) // ç¡®ä¿å®ƒæœ‰å¯¹åº”çš„ DOM å…ƒç´ 
            .sort((a, b) => new Date(a.date) - new Date(b.date)) // æŒ‰æ—¶é—´é¡ºåºè¿æ¥
            .map(m => m.element); // åªè·å– DOM å…ƒç´ 

        if (elements.length < 2) return; // è‡³å°‘éœ€è¦ä¸¤ä¸ªç‚¹æ‰èƒ½è¿çº¿

        // 3. å¾ªç¯ç»˜åˆ¶çº¿æ¡ (ä»ç‚¹ 1 åˆ° 2, 2 åˆ° 3, ...)
        for (let i = 0; i < elements.length - 1; i++) {
            const el1 = elements[i];
            const el2 = elements[i + 1];

            const node1 = el1.memoryNode;
            const node2 = el2.memoryNode;

            if (!node1 || !node2) continue; // å®‰å…¨æ£€æŸ¥

            // 4. è®¡ç®—èŠ‚ç‚¹çš„ç»å¯¹ä½ç½® (ç›¸å¯¹äº #baseMap)
            const x1 = el1.offsetLeft + node1.offsetLeft + (node1.offsetWidth / 2);
            const y1 = el1.offsetTop + node1.offsetTop + (node1.offsetHeight / 2);
            const x2 = el2.offsetLeft + node2.offsetLeft + (node2.offsetWidth / 2);
            const y2 = el2.offsetTop + node2.offsetTop + (node2.offsetHeight / 2);

            // 5. åˆ›å»º SVG <path> å…ƒç´ 
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', `M${x1},${y1} L${x2},${y2}`);
            path.setAttribute('class', 'connection-line');
            path.setAttribute('data-type', type);
            path.style.stroke = memoryTypes[type].color;

            svgLayer.appendChild(path);
        }
    }

    /**
     * è‡ªåŠ¨ç¼©æ”¾åœ°å›¾ä»¥é€‚åº”æ‰€æœ‰è®°å¿†èŠ‚ç‚¹
     */
    function fitToMemories() {
        if (!panzoomInstance || memories.length === 0) return;

        const elements = memories.filter(m => m.element).map(m => m.element);
        if (elements.length === 0) return;

        // è®¡ç®—æ‰€æœ‰èŠ‚ç‚¹çš„è¾¹ç•Œæ¡†
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

        elements.forEach(el => {
            const x = el.offsetLeft;
            const y = el.offsetTop;
            const width = el.offsetWidth;
            const height = el.offsetHeight;

            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x + width);
            maxY = Math.max(maxY, y + height);
        });

        // æ·»åŠ 20%çš„è¾¹è·
        const padding = 0.2;
        const width = maxX - minX;
        const height = maxY - minY;
        minX -= width * padding;
        minY -= height * padding;
        maxX += width * padding;
        maxY += height * padding;

        // è®¡ç®—éœ€è¦çš„ç¼©æ”¾æ¯”ä¾‹
        const container = baseMap.parentElement;
        const containerWidth = container.offsetWidth;
        const containerHeight = container.offsetHeight;
        const contentWidth = maxX - minX;
        const contentHeight = maxY - minY;

        const scaleX = containerWidth / contentWidth;
        const scaleY = containerHeight / contentHeight;
        const targetScale = Math.min(scaleX, scaleY, 5); // ä¸è¶…è¿‡æœ€å¤§ç¼©æ”¾

        // è®¡ç®—ä¸­å¿ƒç‚¹
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;

        // è®¡ç®—å¹³ç§»è·ç¦»
        const x = containerWidth / 2 - centerX * targetScale;
        const y = containerHeight / 2 - centerY * targetScale;

        // æ‰§è¡Œç¼©æ”¾å’Œå¹³ç§»ï¼ˆå¸¦åŠ¨ç”»ï¼‰
        panzoomInstance.zoom(targetScale, { animate: true });
        setTimeout(() => {
            panzoomInstance.pan(x, y, { animate: true });
        }, 100);
    }

    /**
     * è·³è½¬åˆ°æŒ‡å®šç±»åˆ«çš„èŠ‚ç‚¹ç°‡
     * @param {string} category - ç±»åˆ«åç§°
     */
    /**
     * è·³è½¬åˆ°æŒ‡å®šç±»åˆ«çš„èŠ‚ç‚¹ç°‡
     * @param {string} category - ç±»åˆ«åç§°
     */
    /**
     * è·³è½¬åˆ°æŒ‡å®šç±»åˆ«çš„èŠ‚ç‚¹ç°‡ (æœ€ç»ˆä¿®å¤ç‰ˆ)
     * @param {string} category - ç±»åˆ«åç§°
     */
    function jumpToCategory(category) {
        if (!panzoomInstance || !categoryCenters[category]) return;

        const categoryMemories = memories.filter(m => m.type === category && m.element);
        if (categoryMemories.length === 0) {
            alert(`è¿˜æ²¡æœ‰${memoryTypes[category].name}å“¦ï¼`);
            return;
        }

        // 1) æ±‚è¯¥ç±»åˆ«ç°‡çš„è¾¹ç•Œæ¡†
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        categoryMemories.forEach(m => {
            const el = m.element;
            const x = el.offsetLeft, y = el.offsetTop;
            const w = el.offsetWidth, h = el.offsetHeight;
            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x + w);
            maxY = Math.max(maxY, y + h);
        });

        // 2) è®¡ç®—åˆé€‚ç¼©æ”¾ï¼ˆå¸¦ 20% paddingï¼‰
        const container = baseMap.parentElement;
        const padding = 0.2;
        const contentW = (maxX - minX) * (1 + padding * 2);
        const contentH = (maxY - minY) * (1 + padding * 2);

        const containerW = container.offsetWidth;
        const containerH = container.offsetHeight;

        let targetScale = Math.min(containerW / contentW, containerH / contentH);
        const MIN = 0.3, MAX = 5;
        targetScale = Math.max(MIN, Math.min(MAX, targetScale));

        // 3) è®¡ç®—å†…å®¹ä¸­å¿ƒç‚¹
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;

        // 4) ã€å…³é”®ä¿®å¤ã€‘
        // æˆ‘ä»¬åˆ†ä¸¤æ­¥æ‰§è¡ŒåŠ¨ç”»ï¼Œé¿å…å†²çª

        // 4.1) è®¡ç®—åœ¨ *å½“å‰* ç¼©æ”¾çº§åˆ«ä¸‹ï¼Œè®© (centerX, centerY) å±…ä¸­æ‰€éœ€çš„å¹³ç§»é‡
        const currentScale = panzoomInstance.getScale();
        const panX = (containerW / 2) - centerX * currentScale;
        const panY = (containerH / 2) - centerY * currentScale;

        // 4.2) æ‰§è¡Œå¹³ç§»åŠ¨ç”»ã€‚
        // .pan() æ–¹æ³•ä¼šè¿”å›ä¸€ä¸ª Promiseï¼Œåœ¨åŠ¨ç”»ç»“æŸåè§£æ
        panzoomInstance.pan(panX, panY, {
            animate: true,
            duration: 400 // 0.4ç§’
        })
            .then(() => {
                // 4.3) å¹³ç§»ç»“æŸåï¼Œæ‰§è¡Œç¼©æ”¾åŠ¨ç”»
                // æˆ‘ä»¬ä»¥å†…å®¹ä¸­å¿ƒ (centerX, centerY) ä¸ºç„¦ç‚¹ (focal point) è¿›è¡Œç¼©æ”¾
                // è¿™æ ·å®ƒå°±ä¼šåœ¨å±…ä¸­çš„ä½ç½®ä¸Šâ€œæ”¾å¤§â€
                panzoomInstance.zoom(targetScale, {
                    animate: true,
                    duration: 300, // 0.3ç§’
                    focal: { x: centerX, y: centerY }
                });
            });
    }

</script>
</body>
</html>